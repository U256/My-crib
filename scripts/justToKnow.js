'use strict'; // переключает движок в «современный» режим, изменяя поведение некоторых встроенных функций. нужно ставить в начале скрипта
// вместо всего скрипта "use strict" можно поставить в начале большинства видов функций. 
// Это позволяет включить строгий режим только в конкретной функции. Но обычно используют его для файла.

//bdd - behavioour driven development подход к разработке
//chai - библиотека для проверок
//sinon - close to previous

//Babel - транспиллер. Превращает современный js в старый стандарт

//ВАРИАНТЫ ПОДКЛЮЧИТЬ К ДОКУМЕНТУ: inline (прям атрибутом) -- internal -- external 

// <script ASYNC></script> - оба атрибута говорят не прерывать загрузку страницы при выполнении
// <script DEFER></script> - отличается тем, что просит выполнить скрипт после загр страницы
// несколько скриптов с такими тегами будут выполняться подряд

//JS игнорирует несколько пробелов
//лучше лишний раз не делать глобальную переменную, а локальную
//Символы $ и _ используются наряду с буквами.

////Пустой return в конце функции не имеет смысла. Он и так там есть, скрытый.

function callAllModals() {
  alert("popup message");
  let xx = prompt("type here:");
  alert(xx);
  confirm("are you sure?");
} // модальные окна

let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}

var summy = 0;
for (let person in salaries) { //in для объектов
  person; // john Ann Pete КЛЮЧИ
  summy += salaries[person]; //100 160 130 ЗНАЧЕНИЯ
} //summy == 390


let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  "1": "США" //При вызове отсортируются!
}; //если нужны именно цифры но в порядке создания, можно задавать "+1", "+49" etc
//свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания


//BOM - обзектная модель браузера. Окна/выпадайки/переходы/
//DOM - объектная модель документа. Все элемены и все их свойства
//DOM дерево:
console.dir(document)// в консоли пишешь DOM получаешь

// HOISTING -поднятие. Инициализация для declared функций и var переменных ДО выполнения кода. var - undefined до момента 
//объявления в коде, но она уже будет существовать!
varry; //undefined
var varry = 2;


//LET VAR LET VAR LET VAR LET VAR LET VAR LET VAR LET VAR LET VAR CONST

var aaa; // видна во всей функциии. Видна всегда, даже до объявл (абзац выше)
let bbb; //видна только в своем {блоке} Видна после объявления, до - ReferenceError: letName is not defined. 

//let нельзя объявить повторно в том же блоке или функции. Это приведет к выбросу исключения SyntaxError.
if (x) {
  let foo1;
  //let foo1; -- SyntaxError thrown.
}

var a = 5;
var b = 10;
if (a === 5) {
  let a = 4; // The scope is inside the if-block 
  var b = 1; // The scope is inside the function
  // inner a = 4 
  // b = 1
}
// a = 5
// b = 1

// можно использовать ключевое слово let для привязки переменных к локальной области видимости цикла for. 
// Разница с использованием var в заголовке цикла for, заключается в том, что переменные объявленные var, будут видны во всей функции, в которой находится этот цикл.
var vv = 0;
for (let i = vv; i < 2; i++) {
  i; //1 2
}

//let, в отличии от var, не создает свойства на глобальном объекте. Например:
var x = 'global_x';
let y = 'global_y';
this.x; // 'global_x'
this.y; // undefined

//const
const MY_FAV = 7;

// MY_FAV = 20; // Uncaught TypeError: Assignment to constant variable

//const MY_FAV = 20; // Uncaught TypeError: Assignment to constant variable

//var MY_FAV = 20; // имя MY_FAV зарезервированно константой выше, данная операция выкинет исключение. let - так же

if (MY_FAV === 7) { // Важно отметить свойства области видимости уровня блока
  // Всё нормально. Создать константу или переменную MY_FAV можно. 
  // (работает так же как и let при объявлении в блоке переменных, которые не const)
  const MY_FAV = 20;

  // MY_FAV теперь 20

  //var MY_FAV = 20; // это попадёт в глобальный контекст и выдаст ошибку
}

///////////////////
//Литерал - фиксир значения объявления: "string"  {value: 1}   [1, 2, 3]
// string value:1  1,2,3 - значения

//область видимости - scope


